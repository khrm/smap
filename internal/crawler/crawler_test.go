package crawler

import (
	"errors"
	"io/ioutil"
	"log"
	"net/url"
	"reflect"
	"sync"
	"testing"

	"github.com/fortytw2/leaktest"
	"github.com/khrm/smap/internal/parser"
	"github.com/khrm/smap/internal/sitemap"
)

var wg sync.WaitGroup

// TestNewConfig test function NewConfig
// This is not that important but generated by gotests
func TestNewConfig(t *testing.T) {
	type args struct {
		r bool
		d int
	}
	tests := []struct {
		name string
		args args
		want *CondConfig
	}{
		{
			name: "TestNewConfig - 1",
			args: args{true, 3},
			want: &CondConfig{
				rootOnly: true,
				depth:    3,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewConfig(tt.args.r, tt.args.d); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewConfig() = %v, want %v", got, tt.want)
			}
		})
	}
}

type mockParser struct{}

func (m *mockParser) ExtractURLs(url string) ([]string, error) {
	switch url {
	case "https://goharbor.io":
		return []string{"https://goharbor.io",
			"/blogs",
			"https://goharbor.io/community",
			"https://goharbor.io/docs",
			"://wrongUrl"}, nil
	case "https://goharbor.io/blogs":
		return []string{"https://goharbor.io",
			"https://goharbor.io/blogs",
			"https://goharbor.io/blogs/harbor-joins-cncf",
			"https://goharbor.io/blogs/hello-world",
			"https://goharbor.io/community",
			"https://goharbor.io/docs"}, nil
	case "https://goharbor.io/blogs/harbor-joins-cncf":
		return []string{"https://goharbor.io",
			"https://goharbor.io/blogs",
			"https://goharbor.io/community",
			"https://goharbor.io/docs"}, nil
	case "https://goharbor.io/blogs/hello-world":
		return []string{"https://goharbor.io",
			"https://goharbor.io/blogs",
			"https://goharbor.io/community",
			"https://nonrooturl/won'tgetadded",
			"https://goharbor.io/docs"}, nil
	case "https://goharbor.io/community":
		return []string{"https://goharbor.io",
			"https://goharbor.io/blogs",
			"https://goharbor.io/community",
			"https://goharbor.io/docs"}, nil
	case "https://goharbor.io/docs":
		return []string{"https://goharbor.io",
			"https://goharbor.io/blogs",
			"https://goharbor.io/community",
			"https://goharbor.io/docs"}, nil
	default:
		return nil, errors.New("crawling failed")
	}
}

// TestNewConfig test function NewConfig
// This is not needed but generated by gotests
func TestNew(t *testing.T) {
	type args struct {
		r     *url.URL
		p     parser.ServiceParse
		l     *log.Logger
		s     *sitemap.SiteMap
		wg    *sync.WaitGroup
		debug bool
	}
	l := log.New(ioutil.Discard, "logger: ", log.Lshortfile)
	sm := sitemap.New()
	u, _ := url.Parse("https://smapKhrm.io")
	tests := []struct {
		name string
		args args
		want *Service
	}{
		{
			name: "TestNew - 1",
			args: args{
				r:     u,
				p:     &mockParser{},
				l:     l,
				s:     sm,
				wg:    &wg,
				debug: false,
			},
			want: &Service{
				root:   u,
				parser: &mockParser{},
				log:    l,
				SM:     sm,
				wg:     &wg,
				debug:  false,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := New(tt.args.r, tt.args.p, tt.args.l, tt.args.s, &wg, false); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("New() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_service_Crawl(t *testing.T) {

	defer leaktest.Check(t)()

	type fields struct {
		root   *url.URL
		parser parser.ServiceParse
		log    *log.Logger
		SM     *sitemap.SiteMap
	}
	type args struct {
		u *url.URL
		c *CondConfig
	}

	u, _ := url.Parse("https://goharbor.io")
	uFail, _ := url.Parse("https://example.com")

	l := log.New(ioutil.Discard, "logger: ", log.Lshortfile)

	f1 := fields{
		root:   u,
		parser: &mockParser{},
		log:    l,
		SM:     sitemap.New(),
	}

	f2 := fields{
		root:   u,
		parser: &mockParser{},
		log:    l,
		SM:     sitemap.New(),
	}

	f3 := fields{
		root:   u,
		parser: &mockParser{},
		log:    l,
		SM:     sitemap.New(),
	}

	want1 := &sitemap.SiteMap{
		URLs: map[string]struct{}{
			"https://goharbor.io":                         {},
			"https://goharbor.io/blogs":                   {},
			"https://goharbor.io/blogs/harbor-joins-cncf": {},
			"https://goharbor.io/blogs/hello-world":       {},
			"https://goharbor.io/community":               {},
			"https://goharbor.io/docs":                    {},
		},
		Connections: map[string]map[string]struct{}{
			"https://goharbor.io": {
				"https://goharbor.io":           struct{}{},
				"https://goharbor.io/blogs":     struct{}{},
				"https://goharbor.io/community": struct{}{},
				"https://goharbor.io/docs":      struct{}{},
			},
			"https://goharbor.io/blogs": {
				"https://goharbor.io":                         struct{}{},
				"https://goharbor.io/blogs":                   struct{}{},
				"https://goharbor.io/blogs/harbor-joins-cncf": struct{}{},
				"https://goharbor.io/blogs/hello-world":       struct{}{},
				"https://goharbor.io/community":               struct{}{},
				"https://goharbor.io/docs":                    struct{}{},
			},
			"https://goharbor.io/blogs/harbor-joins-cncf": {
				"https://goharbor.io":           struct{}{},
				"https://goharbor.io/blogs":     struct{}{},
				"https://goharbor.io/community": struct{}{},
				"https://goharbor.io/docs":      struct{}{},
			},
			"https://goharbor.io/blogs/hello-world": {
				"https://goharbor.io":           struct{}{},
				"https://goharbor.io/blogs":     struct{}{},
				"https://goharbor.io/community": struct{}{},
				"https://goharbor.io/docs":      struct{}{},
			},
			"https://goharbor.io/community": {
				"https://goharbor.io":           struct{}{},
				"https://goharbor.io/blogs":     struct{}{},
				"https://goharbor.io/community": struct{}{},
				"https://goharbor.io/docs":      struct{}{},
			},
			"https://goharbor.io/docs": {
				"https://goharbor.io":           struct{}{},
				"https://goharbor.io/blogs":     struct{}{},
				"https://goharbor.io/community": struct{}{},
				"https://goharbor.io/docs":      struct{}{},
			},
		},
	}

	want2 := &sitemap.SiteMap{
		URLs: map[string]struct{}{
			"https://goharbor.io": {},
		},
		Connections: make(map[string]map[string]struct{}),
	}

	want3 := sitemap.New()
	want4 := &sitemap.SiteMap{
		URLs: map[string]struct{}{
			"https://example.com": {},
		},
		Connections: make(map[string]map[string]struct{}),
	}

	tests := []struct {
		name   string
		fields fields
		args   args
		want   *sitemap.SiteMap
	}{
		{
			name:   "Test_service_Crawl - 1 pos",
			fields: f1,
			args: args{
				u: u,
				c: &CondConfig{
					true,
					13,
				},
			},
			want: want1,
		},
		{
			name:   "Test_service_Crawl - 2 neg",
			fields: f2,
			args: args{
				u: u,
				c: &CondConfig{
					true,
					0,
				},
			},
			want: want2,
		},
		{
			name:   "Test_service_Crawl - 3 neg",
			fields: f3,
			args: args{
				u: u,
				c: nil,
			},
			want: want3,
		},
		{
			name:   "Test_service_Crawl - 4 neg",
			fields: f3,
			args: args{
				u: uFail,
				c: &CondConfig{
					true,
					13,
				},
			},
			want: want4,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := &Service{
				root:   tt.fields.root,
				parser: tt.fields.parser,
				log:    tt.fields.log,
				SM:     tt.fields.SM,
				wg:     &wg,
				debug:  true,
			}
			s.wg.Add(1)
			go s.Crawl(tt.args.u, tt.args.c)
			s.wg.Wait()
			if !reflect.DeepEqual(tt.want, s.SM) {
				t.Errorf("\nNew() = %v, \n want  = %v", s.SM, tt.want)
			}
		})
	}
}
