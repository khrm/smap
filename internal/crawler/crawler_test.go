package crawler

import (
	"io/ioutil"
	"log"
	"net/url"
	"reflect"
	"testing"

	"github.com/khrm/smap/internal/parser"
	"github.com/khrm/smap/internal/sitemap"
)

// TestNewConfig test function NewConfig
// This is not that important but generated by gotests
func TestNewConfig(t *testing.T) {
	type args struct {
		r bool
		d int
	}
	tests := []struct {
		name string
		args args
		want *config
	}{
		{
			name: "TestNewConfig - 1",
			args: args{true, 3},
			want: &config{
				RootOnly: true,
				Depth:    3,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewConfig(tt.args.r, tt.args.d); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewConfig() = %v, want %v", got, tt.want)
			}
		})
	}
}

type mockParser struct{}

func (m *mockParser) ExtractURLs(url string) ([]string, error) {
	switch url {
	case "https://goharbor.io":
		return []string{"https://goharbor.io",
			"https://goharbor.io/blogs",
			"https://goharbor.io/community",
			"https://goharbor.io/docs"}, nil
	case "https://goharbor.io/blogs":
		return []string{"https://goharbor.io",
			"https://goharbor.io/blogs",
			"https://goharbor.io/blogs/harbor-joins-cncf",
			"https://goharbor.io/blogs/hello-world",
			"https://goharbor.io/community",
			"https://goharbor.io/docs"}, nil
	case "https://goharbor.io/blogs/harbor-joins-cncf":
		return []string{"https://goharbor.io",
			"https://goharbor.io/blogs",
			"https://goharbor.io/community",
			"https://goharbor.io/docs"}, nil
	case "https://goharbor.io/blogs/hello-world":
		return []string{"https://goharbor.io",
			"https://goharbor.io/blogs",
			"https://goharbor.io/community",
			"https://goharbor.io/docs"}, nil
	case "https://goharbor.io/community":
		return []string{"https://goharbor.io",
			"https://goharbor.io/blogs",
			"https://goharbor.io/community",
			"https://goharbor.io/docs"}, nil
	case "https://goharbor.io/docs":
		return []string{"https://goharbor.io",
			"https://goharbor.io/blogs",
			"https://goharbor.io/community",
			"https://goharbor.io/docs"}, nil
	}
	return nil, nil
}

// TestNewConfig test function NewConfig
// This is not needed but generated by gotests
func TestNew(t *testing.T) {
	type args struct {
		r *url.URL
		p parser.Parse
		l *log.Logger
		s *sitemap.SiteMap
	}
	l := log.New(ioutil.Discard, "logger: ", log.Lshortfile)
	sm := sitemap.New()
	u, _ := url.Parse("https://smapKhrm.io")
	tests := []struct {
		name string
		args args
		want *service
	}{
		{
			name: "TestNew - 1",
			args: args{
				r: u,
				p: &mockParser{},
				l: l,
				s: sm,
			},
			want: &service{
				root:   u,
				parser: &mockParser{},
				log:    l,
				SM:     sm,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := New(tt.args.r, tt.args.p, tt.args.l, tt.args.s); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("New() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_service_Crawl(t *testing.T) {
	type fields struct {
		root   *url.URL
		parser parser.Parse
		log    *log.Logger
		SM     *sitemap.SiteMap
	}
	type args struct {
		u *url.URL
		c *config
	}

	u, _ := url.Parse("https://goharbor.io")

	l := log.New(ioutil.Discard, "logger: ", log.Lshortfile)

	f := fields{
		root:   u,
		parser: &mockParser{},
		log:    l,
		SM:     sitemap.New(),
	}

	want := &sitemap.SiteMap{
		URLs: map[string]struct{}{
			"https://goharbor.io":                         struct{}{},
			"https://goharbor.io/blogs":                   struct{}{},
			"https://goharbor.io/blogs/harbor-joins-cncf": struct{}{},
			"https://goharbor.io/blogs/hello-world":       struct{}{},
			"https://goharbor.io/community":               struct{}{},
			"https://goharbor.io/docs":                    struct{}{},
		},
		Connections: map[string]map[string]struct{}{
			"https://goharbor.io": {
				"https://goharbor.io":           struct{}{},
				"https://goharbor.io/blogs":     struct{}{},
				"https://goharbor.io/community": struct{}{},
				"https://goharbor.io/docs":      struct{}{},
			},
			"https://goharbor.io/blogs": {
				"https://goharbor.io":                         struct{}{},
				"https://goharbor.io/blogs":                   struct{}{},
				"https://goharbor.io/blogs/harbor-joins-cncf": struct{}{},
				"https://goharbor.io/blogs/hello-world":       struct{}{},
				"https://goharbor.io/community":               struct{}{},
				"https://goharbor.io/docs":                    struct{}{},
			},
			"https://goharbor.io/blogs/harbor-joins-cncf": {
				"https://goharbor.io":           struct{}{},
				"https://goharbor.io/blogs":     struct{}{},
				"https://goharbor.io/community": struct{}{},
				"https://goharbor.io/docs":      struct{}{},
			},
			"https://goharbor.io/blogs/hello-world": {
				"https://goharbor.io":           struct{}{},
				"https://goharbor.io/blogs":     struct{}{},
				"https://goharbor.io/community": struct{}{},
				"https://goharbor.io/docs":      struct{}{},
			},
			"https://goharbor.io/community": {
				"https://goharbor.io":           struct{}{},
				"https://goharbor.io/blogs":     struct{}{},
				"https://goharbor.io/community": struct{}{},
				"https://goharbor.io/docs":      struct{}{},
			},
			"https://goharbor.io/docs": {
				"https://goharbor.io":           struct{}{},
				"https://goharbor.io/blogs":     struct{}{},
				"https://goharbor.io/community": struct{}{},
				"https://goharbor.io/docs":      struct{}{},
			},
		},
	}

	tests := []struct {
		name   string
		fields fields
		args   args
		want   *sitemap.SiteMap
	}{
		{
			name:   "Test_service_Crawl - 1 pos",
			fields: f,
			args: args{
				u: u,
				c: &config{
					true,
					13,
				},
			},
			want: want,
		},
		{
			name:   "Test_service_Crawl - 2 neg",
			fields: f,
			args: args{
				u: u,
				c: &config{
					true,
					0,
				},
			},
			want: sitemap.New(),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := &service{
				root:   tt.fields.root,
				parser: tt.fields.parser,
				log:    tt.fields.log,
				SM:     tt.fields.SM,
			}
			s.Crawl(tt.args.u, tt.args.c)
			if !reflect.DeepEqual(tt.want, s.SM) {
				t.Errorf("New() = %v, want %v", s.SM, tt.want)
			}
		})
	}
}
